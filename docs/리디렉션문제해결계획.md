## Pronto 서비스 코드 품질 개선 계획 (커서 검토 기반)

### 1. 하드코딩 제거 및 설정 중앙화

커서가 지적한 것처럼 코드 여러 곳에 직접 입력된 값들(운영 시간, API 경로, 캐싱 시간, 타임존 등)이 발견되었습니다.

* **개선 액션:**
    * **액션 1.1:** 운영 시작/종료 시간, 기본 운영 시간 (`src/lib/date-utils.ts`, API 라우트) → 환경 변수 (`NEXT_PUBLIC_OPERATION_START_TIME` 등) 또는 중앙 설정 파일 (`src/config/operation.config.ts` 등)로 이동.
    * **액션 1.2:** API 호출 경로 (`src/features/reservation/components/TimeRangeSelector.tsx` 등) → `src/constants/apiPaths.ts` 또는 `src/lib/apiClient.ts`와 같은 중앙 관리 지점으로 분리.
    * **액션 1.3:** 캐싱 시간 (API 라우트의 900초) → `src/constants/cacheTimes.ts` 또는 환경 변수로 분리.
    * **액션 1.4:** 타임존 ('Asia/Seoul') → `src/constants/region.ts` 또는 환경 변수로 분리.

* **개선 이유:**
    * **변경 용이성:** 서비스 정책 변경(예: 운영 시간 변경)이나 환경별 설정(예: 개발 API vs 운영 API)이 필요할 때, 코드 전체를 뒤지지 않고 한 곳(환경 변수 또는 설정 파일)만 수정하면 되므로 매우 편리해집니다.
    * **유지보수성 향상:** 설정값이 코드와 분리되면 코드는 로직에만 집중할 수 있고, 설정 변경으로 인한 예기치 않은 코드 오류 발생 가능성이 줄어듭니다.
    * **유연성 확보:** 다양한 환경(개발, 스테이징, 운영)에 따라 다른 설정을 쉽게 적용할 수 있고, 향후 서비스 확장(예: 다른 지역 서비스)에도 유연하게 대응할 수 있습니다.

### 2. 데이터 하드코딩 분리 및 API 연동 준비

`ServiceDetailClient.tsx` 컴포넌트 내에 시설 안내, 환불 정책, 주차 정보, FAQ, 기본 이미지 URL 등이 직접 텍스트로 작성되어 있습니다.

* **개선 액션:**
    * **액션 2.1:** UI에 표시되는 텍스트 데이터(시설 안내, 환불 정책, 주차 안내, FAQ 등) → `src/data/serviceInfo.ts`, `src/data/faqData.ts` 등의 별도 파일로 분리 후 컴포넌트에서 임포트하여 사용. (장기적으로는 이 데이터들을 DB에서 관리하고 API를 통해 조회하도록 변경하는 것을 목표로 합니다.)
    * **액션 2.2:** 기본 이미지 URL → `src/constants/images.ts` 파일로 분리하여 상수로 관리.

* **개선 이유:**
    * **콘텐츠 관리 용이성:** UI 텍스트나 기본값들은 서비스 운영 중 자주 변경될 수 있습니다. 코드와 분리해두면 개발자가 아니더라도 (예: 기획자, 마케터) 해당 파일만 수정하여 쉽게 내용을 업데이트할 수 있습니다.
    * **코드 가독성 향상:** 컴포넌트 코드에서 긴 텍스트 덩어리들이 사라지므로, 컴포넌트의 주요 로직과 구조를 파악하기 쉬워집니다.
    * **향후 DB 연동 용이:** 지금 당장 DB 연동이 어렵더라도, 데이터를 별도 파일로 분리해두면 나중에 이 파일의 내용을 DB로 옮기고 API를 통해 가져오도록 수정하기가 훨씬 수월해집니다.

### 3. 컴포넌트 리팩토링 (확장성 및 유지보수성 향상)

`TimeRangeSelector.tsx` (666줄)와 `ServiceDetailClient.tsx` (526줄) 컴포넌트가 너무 크고 많은 기능을 담당하고 있습니다.

* **개선 액션:**
    * **액션 3.1:** `TimeRangeSelector.tsx` 컴포넌트를 기능 단위로 분리합니다. (커서 제안: `TimeSlotGrid`, `TimeSlotHeader`, `TimeSlotControls`, `TimeRangeInfo`, `TimeSlotLegend` 등. 디렉토리 구조는 `src/features/reservation/components/TimeRangeSelector/` 하위로 구성)
    * **액션 3.2:** `ServiceDetailClient.tsx` 컴포넌트를 기능 단위로 분리합니다. (커서 제안: `ServiceHeader`, `ServiceImageGallery`, `ServicePriceInfo`, `ServiceLocation`, `ServiceRating`, `ServiceTabs` 및 각 탭별 컴포넌트 등. 디렉토리 구조는 `src/features/service/components/ServiceDetail/` 하위로 구성)
    * **액션 3.3:** 분리된 컴포넌트들에 Presentational/Container 패턴 또는 이와 유사한 관심사 분리 패턴(예: 커스텀 훅을 사용하여 로직 분리)을 적용하여 UI 렌더링과 상태 및 로직 관리를 분리합니다.
    * **액션 3.4:** 예약 관련 주요 상태(선택된 날짜, 시간 범위, 예약 폼 데이터 등)를 Zustand 스토어(`src/features/reservation/stores/reservationStore.ts`, `src/features/reservation/stores/bookingFormStore.ts` 등)로 이전하여 props drilling(여러 계층으로 props를 계속 전달하는 것)을 줄이고 상태 관리를 중앙화합니다. 서비스 상세 정보 관련 상태도 `src/features/service/stores/serviceDetailStore.ts` 등으로 관리할 수 있습니다.

* **개선 이유:**
    * **이해하기 쉬운 코드:** 작은 컴포넌트는 각자의 역할이 명확해서 코드를 읽고 이해하기가 훨씬 쉽습니다. "이 컴포넌트는 딱 이 일만 하는구나!" 하고 바로 알 수 있죠.
    * **수정 용이성 및 낮은 버그 위험:** 특정 기능을 수정할 때, 관련된 작은 컴포넌트만 보면 되므로 전체 코드에 미치는 영향을 걱정할 필요가 줄어듭니다. 이는 버그 발생 가능성을 낮춥니다.
    * **재사용성 증가:** 잘게 쪼개진 범용적인 컴포넌트들은 다른 페이지나 다른 기능에서도 가져다 쓰기 좋습니다. 똑같은 코드를 여러 번 작성할 필요가 없어집니다.
    * **테스트 용이성:** 작은 단위의 컴포넌트는 테스트하기도 훨씬 간편합니다.
    * **협업 효율 증가:** 여러 개발자가 동시에 작업할 때, 각자 다른 작은 컴포넌트를 맡아 작업하면 충돌이 줄어들고 효율적으로 협업할 수 있습니다.
    * **상태 관리 단순화:** 전역 상태 관리를 사용하면 여러 컴포넌트에서 동일한 데이터를 쉽게 공유하고 업데이트할 수 있어, 복잡한 데이터 흐름을 단순하게 만들 수 있습니다.

### 4. 코드 중복 제거 및 유틸리티 함수 중앙화

여러 파일에 비슷한 시간 변환 및 포맷팅 함수들이 중복되어 사용되고 있습니다.

* **개선 액션:**
    * **액션 4.1:** `timeToMinutes`, `formatMinutesToTime`, `formatTimeString` 등 여러 파일에 중복된 시간 관련 유틸리티 함수들을 `src/lib/date-utils.ts` 파일로 통합하고, 다른 파일에서는 이 파일을 임포트하여 사용하도록 리팩토링합니다. 커서가 제안한 통합 함수 시그니처를 참고합니다.

* **개선 이유:**
    * **DRY (Don't Repeat Yourself) 원칙:** "반복하지 마라"는 개발의 중요한 원칙입니다. 똑같은 코드가 여러 곳에 있으면, 나중에 수정할 일이 생겼을 때 모든 곳을 찾아 빠짐없이 고쳐야 합니다. 하나라도 놓치면 버그가 생기죠.
    * **유지보수 효율성:** 한 곳에 모아두면 수정이 필요할 때 그 파일만 고치면 되므로 매우 효율적입니다.
    * **일관성 유지:** 모든 곳에서 동일한 로직을 사용하므로 결과의 일관성이 보장됩니다.

### 5. 타입 시스템 강화 (TypeScript)

`TimeSlot` 타입 정의가 여러 곳에서 다르게 사용되거나, `any` 타입이 사용되는 등 타입 안전성이 부족한 부분이 있습니다.

* **개선 액션:**
    * **액션 5.1:** `src/types/reservation.ts` (또는 `src/types/index.ts`)를 기준으로 `TimeSlot` 타입을 통합하고, 일관된 타입을 사용하도록 수정합니다. 커서가 제안한 JSDoc 주석이 포함된 상세한 타입을 참고합니다.
    * **액션 5.2:** 코드 전반적으로 `any` 타입 사용을 최소화하고, 가능한 구체적인 타입을 정의하여 사용합니다. 특히 API 응답 데이터에 대한 명확한 타입을 정의하여 데이터의 구조를 예측 가능하게 만듭니다.

* **개선 이유:**
    * **버그 사전 방지:** TypeScript의 가장 큰 장점은 타입을 통해 개발 단계에서부터 오류를 미리 잡을 수 있다는 것입니다. `any` 타입을 남용하면 이 장점을 활용할 수 없습니다. 구체적인 타입을 사용하면 의도치 않은 데이터 타입으로 인한 런타임 오류를 크게 줄일 수 있습니다.
    * **코드 가독성 및 이해도 향상:** 타입 정의는 그 자체로 데이터의 구조와 의도를 설명하는 훌륭한 문서 역할을 합니다. 다른 개발자나 미래의 내가 코드를 볼 때 훨씬 이해하기 쉬워집니다.
    * **개발 생산성 향상:** 명확한 타입은 코드 자동 완성, 리팩토링 등 개발 도구의 지원을 최대한 활용할 수 있게 해줍니다.

### 6. 스타일링 개선 (Tailwind CSS)

반복적인 Tailwind CSS 클래스 조합이나 커스텀 색상 정의에 대한 개선점이 있습니다.

* **개선 액션:**
    * **액션 6.1:** 자주 사용되는 Tailwind CSS 클래스 조합(예: 카드 스타일)은 `@apply`를 사용하여 `globals.css` 내에 유틸리티 클래스로 정의하거나, 커서가 제안한 `Card.tsx`, `InfoItem.tsx`, `TabPanel.tsx`, `FormField.tsx`와 같이 재사용 가능한 UI 컴포넌트로 추출하여 사용합니다.
    * **액션 6.2:** `tailwind.config.js` (또는 `.ts`) 파일의 `theme.extend.colors` 부분에 `pronto-gray-200`, `pronto-primary` 등 프로젝트에서 사용되는 커스텀 색상 팔레트를 명확하게 정의하고, 코드에서는 정의된 테마 색상 이름을 사용합니다. (커서가 제안한 `pronto: { primary: ..., secondary: ..., gray: { ... } }` 구조 참고)

* **개선 이유:**
    * **코드 간결성 및 가독성:** 긴 클래스 문자열이 반복되면 HTML/JSX 코드가 지저분해지고 읽기 어려워집니다. 공통 스타일을 묶어두면 코드가 훨씬 깔끔해집니다.
    * **디자인 일관성 유지:** 공통 컴포넌트나 유틸리티 클래스를 사용하면 서비스 전체적으로 디자인의 일관성을 쉽게 유지할 수 있습니다.
    * **유지보수 용이성:** 스타일 변경이 필요할 때, 해당 컴포넌트나 유틸리티 클래스 정의만 수정하면 모든 곳에 일괄적으로 적용되므로 매우 효율적입니다.
    * **테마 관리:** `tailwind.config.js`에 색상, 폰트, 간격 등을 테마로 정의해두면, 나중에 서비스 전체의 디자인 톤앤매너를 변경해야 할 때 이 설정 파일만 수정하여 쉽게 대응할 수 있습니다.

### 7. 문서화 및 주석 개선

복잡한 로직이나 주요 함수에 대한 주석이 부족한 부분이 있습니다.

* **개선 액션:**
    * **액션 7.1 & 7.2:** `TimeRangeSelector.tsx` 내부의 복잡한 시간 슬롯 선택 로직, 주요 함수, 커스텀 훅 등에 JSDoc 형식의 주석을 추가하여 기능, 매개변수, 반환값 등을 명확히 설명합니다. 다른 주요 컴포넌트 및 유틸리티 함수에도 필요한 주석을 보강합니다.

* **개선 이유:**
    * **코드 이해도 향상:** 잘 작성된 주석은 코드를 처음 보는 사람이나 오랜만에 다시 보는 사람(미래의 나 자신 포함)이 코드의 의도와 작동 방식을 빠르게 파악하는 데 큰 도움을 줍니다.
    * **협업 효율 증진:** 여러 사람이 함께 작업할 때, 주석은 서로의 코드를 이해하고 효과적으로 협업하는 데 필수적입니다.
    * **유지보수 용이성:** 코드를 수정하거나 기능을 추가할 때, 주석은 해당 코드의 컨텍스트를 제공하여 실수를 줄이고 작업 효율을 높입니다.

위 개선 사항들을 반영하면 Pronto 서비스의 코드가 훨씬 더 견고하고, 유연하며, 관리하기 쉬운 형태로 발전할 것입니다.
