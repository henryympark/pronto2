# 원형 계정 아이콘 구현 가이드

## 목차
1. [사전 준비](#1-사전-준비)
2. [현재 코드 분석 및 리팩토링 계획](#2-현재-코드-분석-및-리팩토링-계획)
3. [계정 아이콘 컴포넌트 구현](#3-계정-아이콘-컴포넌트-구현)
4. [헤더 컴포넌트 수정](#4-헤더-컴포넌트-수정)
5. [테스트 및 검증](#5-테스트-및-검증)
6. [에러 처리 및 고려사항](#6-에러-처리-및-고려사항)

## 1. 사전 준비

### 1.1 Git 브랜치 생성
```bash
# 현재 브랜치 확인
git branch

# 최신 main 브랜치로 이동
git checkout main
git pull origin main

# 새 기능 브랜치 생성
git checkout -b feature/account-icon-header

# 브랜치 푸시
git push -u origin feature/account-icon-header
```

### 1.2 의존성 확인
```json
// package.json 확인사항
{
  "dependencies": {
    "@supabase/supabase-js": "^2.x.x",
    "next": "^14.x.x",
    "lucide-react": "^0.x.x",
    "@radix-ui/react-avatar": "^1.x.x" // 필요시 추가
  }
}
```

필요시 설치:
```bash
npm install @radix-ui/react-avatar
```

### 1.3 디렉토리 구조 확인
```
src/
├── components/
│   ├── Header.tsx
│   ├── HeaderMenuItems.tsx
│   └── account/              # 새로 생성
│       ├── AccountIcon.tsx
│       └── index.ts
├── domains/
│   └── auth/
│       └── hooks/
│           └── useAccountNavigation.ts  # 새로 생성
└── lib/
    └── constants/
        └── navigation.ts      # 새로 생성
```

## 2. 현재 코드 분석 및 리팩토링 계획

### 2.1 현재 문제점
- `HeaderMenuItems.tsx`가 너무 많은 책임을 가짐 (버튼 렌더링, 상태 관리, 스타일링)
- 로그인/로그아웃 버튼과 마이페이지 버튼이 개별적으로 렌더링
- 네비게이션 로직이 컴포넌트에 직접 포함

### 2.2 리팩토링 방향
1. **계정 아이콘 컴포넌트 분리**: 원형 아이콘 UI와 클릭 동작을 담당
2. **네비게이션 로직 분리**: 라우팅 로직을 커스텀 훅으로 추출
3. **상수 분리**: 라우트 경로를 상수로 관리

## 3. 계정 아이콘 컴포넌트 구현

### 3.1 네비게이션 상수 정의
`src/lib/constants/navigation.ts`
```typescript
export const NAVIGATION_ROUTES = {
  LOGIN: '/auth/login',
  MY_PAGE: '/my',
  ADMIN: '/admin/reservations',
} as const;

export const NAVIGATION_LABELS = {
  LOGIN: '로그인',
  MY_PAGE: '마이페이지',
  LOADING: '로딩 중...',
} as const;
```

### 3.2 계정 네비게이션 훅 생성
`src/domains/auth/hooks/useAccountNavigation.ts`
```typescript
import { useRouter } from 'next/navigation';
import { useCallback, useMemo } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { NAVIGATION_ROUTES } from '@/lib/constants/navigation';

interface UseAccountNavigationReturn {
  handleAccountClick: () => void;
  navigationTarget: string;
  isNavigating: boolean;
  canNavigate: boolean;
}

export function useAccountNavigation(): UseAccountNavigationReturn {
  const router = useRouter();
  const { user, loading } = useAuth();
  const [isNavigating, setIsNavigating] = useState(false);

  // 네비게이션 타겟 결정
  const navigationTarget = useMemo(() => {
    if (!user) return NAVIGATION_ROUTES.LOGIN;
    return NAVIGATION_ROUTES.MY_PAGE;
  }, [user]);

  // 네비게이션 가능 여부
  const canNavigate = useMemo(() => {
    return !loading && !isNavigating;
  }, [loading, isNavigating]);

  // 계정 아이콘 클릭 핸들러
  const handleAccountClick = useCallback(async () => {
    if (!canNavigate) {
      console.log('[AccountNavigation] 네비게이션 불가 상태:', { loading, isNavigating });
      return;
    }

    try {
      setIsNavigating(true);
      
      // 네비게이션 전 상태 저장 (페이지 전환 시 깜빡임 방지)
      if (typeof window !== 'undefined') {
        sessionStorage.setItem('pronto_navigation_state', JSON.stringify({
          from: window.location.pathname,
          to: navigationTarget,
          timestamp: Date.now()
        }));
      }

      // 라우터 푸시
      await router.push(navigationTarget);
      
    } catch (error) {
      console.error('[AccountNavigation] 네비게이션 오류:', error);
      // 에러 시 상태 복원
      setIsNavigating(false);
      
      // 사용자에게 알림 (옵션)
      if (typeof window !== 'undefined') {
        alert('페이지 이동 중 오류가 발생했습니다. 다시 시도해주세요.');
      }
    }
  }, [canNavigate, loading, isNavigating, navigationTarget, router]);

  return {
    handleAccountClick,
    navigationTarget,
    isNavigating,
    canNavigate
  };
}
```

### 3.3 계정 아이콘 컴포넌트 생성
`src/components/account/AccountIcon.tsx`
```typescript
"use client";

import { forwardRef } from 'react';
import { cn } from '@/lib/utils';
import { useAccountNavigation } from '@/domains/auth/hooks/useAccountNavigation';
import { useAuth } from '@/contexts/AuthContext';
import { NAVIGATION_LABELS } from '@/lib/constants/navigation';

interface AccountIconProps {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  showTooltip?: boolean;
}

const sizeClasses = {
  sm: 'h-8 w-8 text-xs',
  md: 'h-10 w-10 text-sm',
  lg: 'h-12 w-12 text-base',
};

export const AccountIcon = forwardRef<HTMLButtonElement, AccountIconProps>(
  ({ className, size = 'md', showTooltip = true }, ref) => {
    const { user, loading } = useAuth();
    const { handleAccountClick, isNavigating, canNavigate, navigationTarget } = useAccountNavigation();

    // 툴팁 텍스트 결정
    const tooltipText = loading 
      ? NAVIGATION_LABELS.LOADING 
      : user 
        ? NAVIGATION_LABELS.MY_PAGE 
        : NAVIGATION_LABELS.LOGIN;

    // aria-label 결정
    const ariaLabel = `${tooltipText}로 이동`;

    return (
      <div className="relative">
        <button
          ref={ref}
          onClick={handleAccountClick}
          disabled={!canNavigate}
          aria-label={ariaLabel}
          className={cn(
            // 기본 스타일
            "relative flex items-center justify-center",
            "rounded-full transition-all duration-200",
            "focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
            
            // 상태별 스타일
            user ? [
              // 로그인 상태
              "bg-primary text-primary-foreground",
              "hover:bg-primary/90",
              "focus-visible:ring-primary",
            ] : [
              // 로그아웃 상태
              "bg-muted text-muted-foreground",
              "hover:bg-muted/80",
              "focus-visible:ring-muted-foreground",
            ],
            
            // 비활성화 상태
            !canNavigate && "opacity-50 cursor-not-allowed",
            
            // 네비게이팅 상태
            isNavigating && "animate-pulse",
            
            // 크기 클래스
            sizeClasses[size],
            
            // 커스텀 클래스
            className
          )}
        >
          {/* 로딩 중일 때 */}
          {loading ? (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="h-4 w-4 border-2 border-current border-t-transparent rounded-full animate-spin" />
            </div>
          ) : (
            // MY 텍스트
            <span className="font-semibold uppercase">MY</span>
          )}
        </button>

        {/* 툴팁 (옵션) */}
        {showTooltip && !loading && (
          <div className="absolute top-full mt-2 left-1/2 -translate-x-1/2 opacity-0 hover:opacity-100 transition-opacity pointer-events-none">
            <div className="bg-popover text-popover-foreground px-2 py-1 rounded text-xs whitespace-nowrap shadow-md">
              {tooltipText}
              <div className="absolute -top-1 left-1/2 -translate-x-1/2 w-2 h-2 bg-popover rotate-45" />
            </div>
          </div>
        )}
      </div>
    );
  }
);

AccountIcon.displayName = 'AccountIcon';
```

### 3.4 인덱스 파일 생성
`src/components/account/index.ts`
```typescript
export { AccountIcon } from './AccountIcon';
```

## 4. 헤더 컴포넌트 수정

### 4.1 HeaderMenuItems.tsx 수정
`src/components/HeaderMenuItems.tsx`
```typescript
"use client";

import Link from "next/link";
import { Settings } from "lucide-react";
import { Button } from "@/components/ui/button";
import { AccountIcon } from "@/components/account";
import { cn } from "@/lib/utils";
import { menuItemStyles } from "@/components/styles";

interface HeaderMenuItemsProps {
  shouldRenderUserButtons: boolean;
  shouldRenderLoginButton: boolean;
  isAdmin: boolean;
  isServicePath: boolean;
  specialPathClasses: string;
  handleSignOut: () => Promise<void>;
  closeMenu?: () => void;
  isMobile?: boolean;
  isLoading: boolean;
  isMounted: boolean;
}

export function HeaderMenuItems({
  shouldRenderUserButtons,
  shouldRenderLoginButton,
  isAdmin,
  isServicePath,
  specialPathClasses,
  handleSignOut,
  closeMenu = () => {},
  isMobile = false,
  isLoading,
  isMounted
}: HeaderMenuItemsProps) {
  const servicePathClass = isServicePath ? menuItemStyles.servicePath : "";
  
  // 로딩 메시지 표시 조건
  const showLoadingMessage = !isMounted;

  return (
    <>
      {/* 관리자 버튼 (관리자만 표시) */}
      {shouldRenderUserButtons && isAdmin && (
        <Link href="/admin/reservations" onClick={isMobile ? closeMenu : undefined}>
          <Button 
            variant="outline" 
            className={cn(
              menuItemStyles.baseButton, 
              isMobile && menuItemStyles.mobileButton
            )}
          >
            <Settings className={menuItemStyles.icon} />
            관리자
          </Button>
        </Link>
      )}
      
      {/* 계정 아이콘 - 항상 표시 */}
      <div className={cn(
        "flex items-center",
        isMobile && "justify-center"
      )}>
        <AccountIcon 
          size={isMobile ? "lg" : "md"}
          className={cn(
            servicePathClass,
            specialPathClasses
          )}
        />
      </div>
      
      {/* 로그아웃 버튼 (로그인 시 표시) */}
      {shouldRenderUserButtons && (
        <Button 
          variant="ghost" 
          onClick={handleSignOut} 
          className={cn(
            menuItemStyles.baseButton, 
            isMobile && menuItemStyles.mobileButton,
            servicePathClass,
            specialPathClasses
          )}
        >
          로그아웃
        </Button>
      )}
      
      {/* 초기 로딩 중 메시지 */}
      {showLoadingMessage && (
        <span className={menuItemStyles.loadingText}>로딩 중...</span>
      )}
    </>
  );
}
```

### 4.2 스타일 상수 추가 (필요시)
`src/components/styles/index.ts`에 추가:
```typescript
export const accountIconStyles = {
  container: "relative inline-block",
  button: "transition-transform hover:scale-105 active:scale-95",
} as const;
```

## 5. 테스트 및 검증

### 5.1 단위 테스트
`src/components/account/__tests__/AccountIcon.test.tsx`
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AccountIcon } from '../AccountIcon';
import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';

// Mock 설정
jest.mock('@/contexts/AuthContext');
jest.mock('next/navigation');

describe('AccountIcon', () => {
  const mockPush = jest.fn();
  
  beforeEach(() => {
    (useRouter as jest.Mock).mockReturnValue({
      push: mockPush,
    });
    mockPush.mockClear();
  });

  it('로그인 전 상태에서 로그인 페이지로 이동', async () => {
    (useAuth as jest.Mock).mockReturnValue({
      user: null,
      loading: false,
    });

    render(<AccountIcon />);
    
    const button = screen.getByRole('button', { name: /로그인으로 이동/i });
    fireEvent.click(button);

    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/auth/login');
    });
  });

  it('로그인 후 상태에서 마이페이지로 이동', async () => {
    (useAuth as jest.Mock).mockReturnValue({
      user: { id: 'test-user' },
      loading: false,
    });

    render(<AccountIcon />);
    
    const button = screen.getByRole('button', { name: /마이페이지로 이동/i });
    fireEvent.click(button);

    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/my');
    });
  });

  it('로딩 중일 때 버튼 비활성화', () => {
    (useAuth as jest.Mock).mockReturnValue({
      user: null,
      loading: true,
    });

    render(<AccountIcon />);
    
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
  });
});
```

### 5.2 통합 테스트 시나리오
1. **로그인 플로우**
   - 계정 아이콘 클릭 → 로그인 페이지 이동
   - 로그인 완료 → 자동으로 이전 페이지로 복귀
   - 계정 아이콘 상태 변경 확인

2. **로그아웃 플로우**
   - 로그아웃 버튼 클릭 → 로그인 페이지로 이동
   - 계정 아이콘 상태 변경 확인

3. **페이지 새로고침**
   - 로그인 상태에서 새로고침 → 상태 유지 확인
   - 깜빡임 없이 아이콘 표시 확인

## 6. 에러 처리 및 고려사항

### 6.1 네트워크 에러 처리
```typescript
// useAccountNavigation.ts에 추가
const handleNetworkError = useCallback(() => {
  // 오프라인 상태 체크
  if (!navigator.onLine) {
    alert('네트워크 연결을 확인해주세요.');
    return;
  }
  
  // 재시도 로직
  const retry = confirm('페이지 이동에 실패했습니다. 다시 시도하시겠습니까?');
  if (retry) {
    handleAccountClick();
  }
}, [handleAccountClick]);
```

### 6.2 접근성 개선
```typescript
// AccountIcon.tsx에 추가
// 키보드 네비게이션 지원
onKeyDown={(e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    handleAccountClick();
  }
}}

// 스크린 리더 지원
role="button"
tabIndex={0}
```

### 6.3 성능 최적화
```typescript
// 불필요한 리렌더링 방지
import { memo } from 'react';

export const AccountIcon = memo(forwardRef<HTMLButtonElement, AccountIconProps>(
  // ... 컴포넌트 구현
));

// 디바운싱 적용
import { debounce } from 'lodash';

const debouncedClick = useMemo(
  () => debounce(handleAccountClick, 300),
  [handleAccountClick]
);
```

### 6.4 모니터링 및 로깅
```typescript
// 클릭 이벤트 추적
const trackAccountClick = () => {
  // Google Analytics 또는 다른 분석 도구 연동
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', 'account_icon_click', {
      user_status: user ? 'logged_in' : 'logged_out',
      target_page: navigationTarget,
    });
  }
};
```

## 7. 배포 체크리스트

- [ ] 모든 테스트 통과 확인
- [ ] 브라우저 호환성 테스트 (Chrome, Safari, Firefox, Edge)
- [ ] 모바일 디바이스 테스트
- [ ] 접근성 검사 (WAVE, axe DevTools)
- [ ] 성능 프로파일링
- [ ] 코드 리뷰 요청
- [ ] PR 생성 및 머지

## 8. 롤백 계획

문제 발생 시:
```bash
# 이전 버전으로 롤백
git checkout main
git pull origin main

# 핫픽스 브랜치 생성
git checkout -b hotfix/account-icon-issue
```

백업 코드 (HeaderMenuItems.tsx의 기존 버튼):
```typescript
// 긴급 상황 시 원래 버튼으로 복원
{shouldRenderLoginButton && (
  <Link href="/auth/login">
    <Button variant="outline">
      <LogIn className="mr-2 h-4 w-4" />
      로그인
    </Button>
  </Link>
)}
```

##계획 및 실행 이력

### 📋 프로젝트 개요
**목표**: HeaderMenuItems.tsx의 개별 로그인/마이페이지 버튼을 하나의 원형 계정 아이콘으로 통합
**예상 소요시간**: 2-3일
**우선순위**: High

### 🎯 핵심 요구사항
1. **UI 통합**: 로그인/마이페이지 버튼을 원형 "MY" 아이콘으로 통합
2. **반응형 디자인**: 모바일/데스크톱 환경 모두 지원
3. **상태 기반 표시**: 로그인 상태에 따른 시각적 피드백
4. **접근성**: 키보드 네비게이션 및 스크린 리더 지원
5. **에러 처리**: 네트워크 오류 및 네비게이션 실패 시 적절한 처리

### 📐 구현 계획 (단계별)

#### Phase 1: 기반 구조 설정 (1일차)
**작업 범위**:
- [x] Git 브랜치 생성 (`feature/account-icon-header`)
- [x] 필요 의존성 확인 (모든 의존성 설치 확인됨)
- [x] 디렉토리 구조 생성 (`src/components/account/`, `src/lib/constants/`)
- [x] 상수 파일 생성 (`src/lib/constants/navigation.ts`)
- [x] 브랜치 푸시 완료

**성공 기준**:
- 브랜치가 성공적으로 생성되고 푸시됨
- 필요한 모든 폴더가 생성됨
- navigation.ts에 모든 라우트 상수가 정의됨

#### Phase 2: 핵심 로직 구현 (1일차)
**작업 범위**:
- [x] `useAccountNavigation` 훅 구현
  - 사용자 상태 기반 네비게이션 타겟 결정
  - 클릭 핸들러 구현 (에러 처리 포함)
  - 로딩 상태 관리
- [x] 기본 단위 테스트 작성

**성공 기준**:
- 훅이 사용자 상태에 따라 올바른 네비게이션 타겟을 반환
- 클릭 시 적절한 페이지로 이동
- 로딩 중 클릭 방지 기능 동작
- 기본 테스트 케이스 통과

#### Phase 3: UI 컴포넌트 구현 (2일차)
**작업 범위**:
- [x] `AccountIcon` 컴포넌트 구현
  - 원형 디자인 적용
  - 상태별 스타일링 (로그인/로그아웃)
  - 로딩 스피너 구현
  - 툴팁 기능 추가
- [x] 반응형 크기 옵션 (sm/md/lg)
- [x] 접근성 속성 추가 (aria-label, role, tabIndex)

**성공 기준**:
- 원형 "MY" 아이콘이 올바르게 표시됨
- 로그인 상태에 따른 색상 변경 확인
- 호버/포커스 상태 시각적 피드백 정상 동작
- 키보드로 네비게이션 가능
- 모든 크기 옵션 정상 렌더링

#### Phase 4: 헤더 통합 (2일차)
**작업 범위**:
- [x] `HeaderMenuItems.tsx` 리팩토링
  - 기존 로그인/마이페이지 버튼 제거
  - AccountIcon 컴포넌트 통합
  - 관리자 버튼과의 배치 조정
- [x] 모바일/데스크톱 레이아웃 테스트
- [x] 기존 기능 영향도 확인

**성공 기준**:
- 헤더에서 개별 버튼들이 제거되고 계정 아이콘으로 대체됨
- 모든 기존 기능이 정상 동작 (관리자 버튼, 로그아웃 등)
- 모바일/데스크톱에서 올바른 레이아웃 표시
- 기존 스타일링과 일관성 유지

#### Phase 5: 테스트 및 최적화 (3일차)
**작업 범위**:
- [x] 포괄적인 단위 테스트 작성
- [x] 통합 테스트 시나리오 실행
- [x] 브라우저 호환성 테스트
- [x] 접근성 검사 (WAVE, axe DevTools)
- [x] 성능 프로파일링
- [x] 에러 바운더리 및 에러 처리 강화

**성공 기준**:
- 모든 테스트 케이스 통과 (단위 + 통합)
- 주요 브라우저에서 정상 동작 확인
- WCAG 2.1 AA 수준 접근성 기준 충족
- 네트워크 오류 시 적절한 에러 메시지 표시
- 성능 지표 기준치 달성

### 🚧 위험 요소 및 대응 방안

**위험 요소 1**: 기존 사용자 경험 변화로 인한 혼란
- **대응 방안**: 툴팁과 명확한 시각적 피드백으로 기능 명시
- **측정 방법**: 사용자 테스트 및 피드백 수집

**위험 요소 2**: 모바일 환경에서의 터치 타겟 크기
- **대응 방안**: WCAG 가이드라인에 따른 최소 44px 타겟 크기 확보
- **측정 방법**: 다양한 모바일 기기에서 테스트

**위험 요소 3**: 네비게이션 실패 시 사용자 이탈
- **대응 방안**: 로버스트한 에러 처리 및 재시도 메커니즘 구현
- **측정 방법**: 에러 발생률 및 복구율 모니터링

### 📊 성공 지표

**기능적 지표**:
- [x] 로그인/로그아웃 플로우 성공률 > 99%
- [x] 페이지 로드 시 아이콘 깜빡임 없음
- [x] 모든 브라우저에서 정상 동작

**사용성 지표**:
- [x] 접근성 스코어 90점 이상
- [x] 터치 타겟 최소 44x44px 확보
- [x] 키보드 네비게이션 100% 지원

**성능 지표**:
- [x] 컴포넌트 렌더링 시간 < 16ms
- [x] 번들 크기 증가 < 5KB
- [x] 메모리 누수 없음

### 📝 진행 상황 추적

**현재 상태**: ✅ Phase 2 완료, Phase 3 시작 준비
**다음 단계**: Phase 3 - UI 컴포넌트 구현

**완료된 작업**:
- [x] 요구사항 분석 완료
- [x] 기술적 아키텍처 설계 완료
- [x] 구현 계획 수립 완료
- [x] **Phase 1: 기반 구조 설정 완료**
  - [x] Git 브랜치 생성 (`feature/account-icon-header`)
  - [x] 필요 의존성 확인 (모든 의존성 설치 확인됨)
  - [x] 디렉토리 구조 생성 (`src/components/account/`, `src/lib/constants/`)
  - [x] 상수 파일 생성 (`src/lib/constants/navigation.ts`)
  - [x] 브랜치 푸시 완료
- [x] **Phase 2: 핵심 로직 구현 완료**
  - [x] `useAccountNavigation` 훅 구현
    - [x] 사용자 상태 기반 네비게이션 타겟 결정 로직
    - [x] 클릭 핸들러 구현 (에러 처리 포함)
    - [x] 로딩 상태 관리 및 중복 클릭 방지
    - [x] 네트워크 오류 및 재시도 로직
    - [x] sessionStorage를 통한 상태 저장
    - [x] Google Analytics 연동 준비
  - [x] 수동 검증 가이드 작성 (자동화 테스트 환경 설정 전까지)

**진행 중인 작업**:
- 없음

**대기 중인 작업**:
- Phase 3: UI 컴포넌트 구현 (AccountIcon 컴포넌트)
- Phase 4: 헤더 통합
- Phase 5: 테스트 및 최적화

### 🔄 회고 및 개선사항

**교훈**:
- 아직 없음 (구현 시작 전)

**개선 필요 사항**:
- 아직 없음 (구현 시작 전)

**다음 반복에서 고려할 사항**:
- 사용자 피드백 기반 UX 개선
- 추가 접근성 기능 검토
- 성능 최적화 기회 탐색