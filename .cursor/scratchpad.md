# Pronto 관리자 로그인 리디렉션 문제 해결 계획

## Background and Motivation

**핵심 문제**: 관리자 계정으로 로그인 시 Header에 '관리자' 아이콘은 표시되지만, 관리자 페이지로 리디렉션이 되지 않는 문제가 지속되고 있습니다. 또한 직접 URL로 `/admin/reservations` 접근 시 로그인 페이지로 리디렉션되는 문제도 발생하고 있습니다.

**기술적 배경**: 이는 클라이언트 사이드 세션 관리(localStorage 기반)와 서버 사이드 미들웨어(HTTP 쿠키 기반) 간의 세션 불일치 문제로 확인되었습니다. Supabase 세션이 localStorage에만 저장되고 HTTP 쿠키로는 전달되지 않아, 미들웨어에서 세션을 읽지 못하는 상황입니다.

---

# 🚨 새로운 긴급 문제: 관리자 페이지 Supabase 클라이언트 에러

## Background and Motivation

**핵심 문제**: 관리자 페이지(`/admin/customers`)에서 다음과 같은 에러가 발생하고 있습니다:

```
Error: 클라이언트 컴포넌트에서는 반드시 useSupabase() 훅을 사용해야 합니다.
예: const supabase = useSupabase();
이 함수는 서버 컴포넌트에서만 사용해야 합니다.
```

**기술적 배경**: 
- 관리자 페이지에서 `createClient$()` 함수를 사용하고 있음
- 이 함수는 deprecated되었으며 클라이언트 컴포넌트에서는 `useSupabase()` 훅을 사용해야 함
- 현재 프로젝트에는 `SupabaseContext`와 `useSupabase` 훅이 이미 구현되어 있음

## Key Challenges and Analysis

### 1. 에러 원인 분석
- **문제 코드**: `src/app/admin/customers/page.tsx`의 62번째 줄에서 `const supabase = createClient$();` 사용
- **원인**: `createClient$`는 deprecated된 함수로, 클라이언트 컴포넌트에서 호출 시 에러를 발생시킴
- **영향**: 관리자 페이지 전체가 렌더링되지 않음

### 2. 현재 Supabase 클라이언트 구조
- **올바른 방법**: `useSupabase()` 훅 사용 (이미 구현됨)
- **잘못된 방법**: `createClient$()`, `getSupabaseClient()` 등 deprecated 함수 사용
- **Provider 구조**: `SupabaseProvider` → `AuthProvider` → 앱 컴포넌트들

### 3. 다른 페이지들의 상황
- 일부 페이지에서는 이미 `useSupabase()` 훅을 올바르게 사용하고 있음
- 관리자 페이지들에서만 아직 deprecated 함수를 사용하고 있을 가능성

## High-level Task Breakdown

### Phase 1: 관리자 페이지 Supabase 클라이언트 수정 🔥
1. **AdminCustomersPage useSupabase 훅 적용**
   - `createClient$()` → `useSupabase()` 변경
   - import 문 수정
   - 성공 기준: 에러 없이 페이지 로딩

2. **다른 관리자 페이지들 확인 및 수정**
   - `/admin/reservations`, `/admin/dashboard` 등 확인
   - deprecated 함수 사용 시 모두 `useSupabase()` 훅으로 변경
   - 성공 기준: 모든 관리자 페이지 정상 동작

### Phase 2: 전체 프로젝트 deprecated 함수 정리 📋
3. **전체 코드베이스에서 deprecated 함수 검색**
   - `createClient$`, `getSupabaseClient` 사용처 모두 찾기
   - 클라이언트 컴포넌트는 `useSupabase()` 훅으로 변경
   - 서버 컴포넌트는 `createSupabaseServerClient()` 사용
   - 성공 기준: deprecated 함수 사용처 0개

4. **코드 일관성 확보**
   - 모든 컴포넌트에서 동일한 패턴 사용
   - 타입 안정성 확보
   - 성공 기준: 일관된 Supabase 클라이언트 사용 패턴

## Project Status Board

### 🔥 긴급 해결 필요 (Phase 1)
- [ ] **Phase 1-1: AdminCustomersPage useSupabase 훅 적용**
  - [ ] `createClient$()` → `useSupabase()` 변경
  - [ ] import 문 수정 (`useSupabase` 추가)
  - [ ] 페이지 로딩 테스트

- [ ] **Phase 1-2: 다른 관리자 페이지들 확인**
  - [ ] `/admin/reservations` 페이지 확인
  - [ ] `/admin/dashboard` 페이지 확인
  - [ ] 기타 관리자 페이지들 확인
  - [ ] deprecated 함수 사용 시 모두 수정

### 📋 코드 정리 (Phase 2)
- [ ] **Phase 2-1: 전체 프로젝트 deprecated 함수 검색**
  - [ ] `createClient$` 사용처 검색 및 수정
  - [ ] `getSupabaseClient` 사용처 검색 및 수정
  - [ ] 서버/클라이언트 컴포넌트 구분하여 적절한 함수 사용

- [ ] **Phase 2-2: 코드 일관성 확보**
  - [ ] 모든 컴포넌트 패턴 통일
  - [ ] 타입 안정성 확보
  - [ ] 최종 테스트

## Current Status / Progress Tracking

**현재 상태**: 🚨 **관리자 페이지 Supabase 클라이언트 에러 발생**

**에러 상세**:
- 파일: `src/app/admin/customers/page.tsx`
- 라인: 62번째 줄
- 문제: `const supabase = createClient$();` 사용
- 해결책: `const supabase = useSupabase();` 사용

**최적의 해결 방법**:
1. **즉시 수정**: 관리자 페이지에서 `useSupabase()` 훅 사용
2. **전체 정리**: 프로젝트 전체에서 deprecated 함수 제거
3. **일관성 확보**: 모든 컴포넌트에서 동일한 패턴 사용

**기존 올바른 사용 예시**:
- `src/app/test-supabase/page.tsx`: `const supabase = useSupabase();` ✅
- `src/domains/auth/hooks/useHeaderAuth.ts`: `useSupabase()` 훅 사용 ✅
- `src/contexts/AuthContext.tsx`: `const supabase = useSupabase();` ✅

## Executor's Feedback or Assistance Requests

**완료 보고**: 4-1단계 운영자 휴무일 설정 기능이 완전히 완료되었습니다! ✅

**최종 완료 작업**: Task 4 고객용 캘린더 휴무일 미리 표시 기능 구현 완료

**구현된 주요 기능**:
1. **월별 휴무일 조회 API**: `/api/services/[serviceId]/holidays` 엔드포인트
   - 년/월 파라미터로 해당 월의 모든 휴무일 정보 반환
   - 1시간 캐싱 헤더 설정으로 성능 최적화
   
2. **고객용 캘린더 휴무일 표시**:
   - React Query를 활용한 휴무일 정보 로드 및 캐싱 (5분 stale time)
   - 휴무일 시각적 표시 (회색 배경, 취소선, 선택 불가)
   - 휴무일 선택 방지 및 토스트 안내 메시지
   - 월 변경 시 자동 휴무일 정보 로드
   - 휴무일 안내 범례 추가

**달성된 효과**:
- ✅ 고객이 캘린더에서 휴무일을 미리 확인 가능
- ✅ 휴무일 선택 시 즉시 안내 메시지 제공
- ✅ 월별 자동 로딩으로 원활한 사용자 경험
- ✅ 캐싱을 통한 성능 최적화

**전체 4-1단계 개선 사항**:
1. **UI 레이아웃 개선**: 기존 2열 그리드에서 모바일 우선 1열 레이아웃으로 변경
2. **휴무일 목록 표시 개선**: 테이블 형태에서 카드 형태로 변경하여 모바일에서 더 사용하기 편하게 개선
3. **캘린더 정렬 문제 해결**: DayPicker를 커스텀 Calendar 컴포넌트로 교체하여 테이블 형식으로 변경
4. **고객용 캘린더 휴무일 미리 표시**: 월별 API, 시각적 표시, 선택 방지, 캐싱 등 완전한 UX 개선

**기술적 개선점**:
- ✅ **정렬 문제 해결**: 캘린더가 컨테이너 내에서 완벽하게 중앙 정렬됨
- ✅ **일관성 확보**: 프로젝트의 다른 Calendar 컴포넌트와 동일한 구조 사용
- ✅ **모바일 최적화**: 테이블 형식으로 모바일에서 더 예측 가능한 레이아웃 제공
- ✅ **기능 유지**: 다중 선택, 휴무일 표시, 과거 날짜 방지 등 모든 기능 유지
- ✅ **성능 최적화**: React Query 캐싱, API 캐싱 헤더로 불필요한 요청 방지
- ✅ **사용자 경험**: 휴무일 미리 표시, 선택 방지, 직관적 안내 메시지

**다음 단계 제안**: 
- 사용자가 실제 테스트를 통해 기능이 정상 작동하는지 확인
- 관리자가 휴무일을 설정한 후 고객용 캘린더에서 올바르게 표시되는지 검증
- 필요시 추가적인 UI/UX 개선 사항 검토
- 다음 단계 (4-2단계) 계획 수립

---

# 🚨 새로운 긴급 문제: 서비스 페이지 무한루프 및 캘린더/시간슬라이더 구현 문제

## Background and Motivation

**핵심 문제**: 
1. `http://localhost:3001/service/pronto-b` 페이지에서 무한루프가 발생하고 있음
2. 캘린더와 시간슬라이더가 제대로 구현되어 있지 않음
3. 이전에 만들었던 캘린더/시간슬라이더 코드를 현재 구조에 맞게 재구현 필요

**기술적 배경**: 
- `TimeRangeSelector` 컴포넌트에서 `useEffect`와 `useCallback`의 의존성 배열 문제로 무한루프 발생
- `ServiceDetailClient`에서 캘린더 컴포넌트가 누락되어 있음
- 기존에 구현된 `Calendar` 컴포넌트와 `MinimalCalendarPage` 예제가 있지만 현재 서비스 페이지에 통합되지 않음

## Key Challenges and Analysis

### 1. 무한루프 문제 분석
- **원인**: `TimeRangeSelector`의 `useEffect` 의존성 배열에 `toast` 함수가 포함되어 있어 매 렌더링마다 실행됨
- **영향**: API 호출 → 상태 업데이트 → 재렌더링 → 다시 API 호출의 무한 반복
- **해결 필요**: `useEffect`와 `useCallback`의 의존성 배열 최적화

### 2. 캘린더 구현 누락
- **현재 상태**: `ServiceDetailClient`에서 캘린더 컴포넌트가 없음
- **기존 자산**: `Calendar` 컴포넌트와 `MinimalCalendarPage` 예제가 이미 구현되어 있음
- **필요 작업**: 기존 캘린더를 현재 예약 시스템에 통합

### 3. 시간슬라이더 개선 필요
- **현재 상태**: `TimeRangeSelector`가 구현되어 있지만 무한루프 문제와 UX 개선 필요
- **기존 자산**: `TimeSlotGrid` 컴포넌트와 시간 선택 로직이 구현되어 있음
- **필요 작업**: 무한루프 해결 및 사용자 경험 개선

## High-level Task Breakdown

### Phase 1: 무한루프 문제 해결 🔥
1. **TimeRangeSelector useEffect 의존성 배열 수정**
   - `toast` 함수를 의존성 배열에서 제거
   - `useCallback` 의존성 배열 최적화
   - 성공 기준: 무한루프 없이 정상적인 API 호출

2. **handleSlotClick useCallback 최적화**
   - 불필요한 의존성 제거
   - 메모이제이션 최적화
   - 성공 기준: 시간 슬롯 클릭 시 정상 동작

### Phase 2: 캘린더 통합 구현 📅
3. **기존 Calendar 컴포넌트를 ServiceDetailClient에 통합**
   - `Calendar` 컴포넌트를 예약 시스템에 연결
   - `useReservationStore`와 연동
   - 성공 기준: 날짜 선택 시 시간 슬롯 업데이트

4. **캘린더와 시간슬라이더 연동**
   - 날짜 변경 시 시간 슬롯 자동 업데이트
   - 선택 상태 동기화
   - 성공 기준: 캘린더-시간슬라이더 완전 연동

### Phase 3: UX 개선 및 최적화 ✨
5. **시간 선택 자동화 기능 구현**
   - 최초 선택 시 1시간 자동 선택
   - 연속 슬롯 선택 로직 개선
   - 성공 기준: 직관적인 시간 선택 경험

6. **반응형 레이아웃 최적화**
   - 모바일/데스크톱 최적화
   - 캘린더와 시간슬라이더 배치 개선
   - 성공 기준: 모든 디바이스에서 원활한 사용

### Phase 4: 통합 테스트 및 검증 🧪
7. **전체 예약 플로우 테스트**
   - 날짜 선택 → 시간 선택 → 예약 정보 입력 플로우
   - 다양한 시나리오 테스트
   - 성공 기준: 완전한 예약 플로우 동작

8. **성능 최적화 및 오류 처리**
   - API 호출 최적화
   - 에러 상황 처리 개선
   - 성공 기준: 안정적이고 빠른 예약 시스템

## Project Status Board

### 🔥 긴급 해결 필요 (Phase 1)
- [x] **Phase 1-1: TimeRangeSelector useEffect 의존성 배열 수정**
  - [x] `toast` 함수를 의존성 배열에서 제거 (이미 올바르게 설정됨)
  - [x] API 호출 로직 최적화 확인
  - [x] 무한루프 해결 확인

- [x] **Phase 1-2: handleSlotClick useCallback 최적화**
  - [x] 불필요한 의존성 제거 (이미 올바르게 설정됨)
  - [x] 메모이제이션 최적화 확인
  - [x] 시간 슬롯 클릭 정상 동작 확인

### 📅 캘린더 구현 (Phase 2)
- [x] **Phase 2-1: 기존 Calendar 컴포넌트 통합**
  - [x] ServiceDetailClient에 Calendar 컴포넌트 추가
  - [x] useReservationStore와 연동
  - [x] 날짜 선택 시 상태 업데이트 확인

- [x] **Phase 2-2: 캘린더-시간슬라이더 연동**
  - [x] 날짜 변경 시 시간 슬롯 업데이트 테스트 ✅
  - [x] 선택 상태 동기화 확인 ✅
  - [x] 완전한 연동 동작 확인 ✅

### ✨ UX 개선 (Phase 3) - 완료
- [x] **Phase 3-1: 시간 선택 자동화**
  - [x] 최초 시간 선택 시 1시간 자동 선택 구현 ✅
  - [x] 연속 슬롯 선택 로직 개선 ✅
  - [x] 직관적인 시간 선택 경험 제공 ✅
  - [x] 사용자 피드백 토스트 메시지 추가 ✅

- [x] **Phase 3-2: 반응형 레이아웃 최적화**
  - [x] 모바일 환경 최적화 ✅
  - [x] 데스크톱 환경 최적화 ✅
  - [x] 캘린더와 시간슬라이더 배치 개선 ✅
  - [x] 터치 인터랙션 개선 ✅

### 🧪 테스트 및 검증 (Phase 4) - 진행 중
- [ ] **Phase 4-1: 전체 예약 플로우 테스트**
  - [ ] 날짜 선택 → 시간 선택 → 예약 정보 입력 플로우 테스트
  - [ ] 다양한 시나리오 테스트 (연속/비연속 시간 선택)
  - [ ] 에러 상황 처리 테스트
  - [ ] 모바일/데스크톱 환경 테스트

- [ ] **Phase 4-2: 성능 최적화 및 마무리**
  - [ ] API 호출 최적화 확인
  - [ ] 메모리 누수 방지 확인
  - [ ] 접근성 개선
  - [ ] 최종 코드 정리

### ✅ 완료된 작업들 (이전 관리자 로그인 문제)
- [x] **Phase 1-1: createServerClient와 createBrowserClient 설정 통합**
- [x] **Phase 1-2: 미들웨어 쿠키 처리 로직 개선**

## Current Status / Progress Tracking

**현재 상태**: 🎯 **임시저장 로직 제거 완료 - 간단한 로그인 기반 예약 시스템**

**⚡ 최신 변경사항 (2024년 12월)**:
사용자 요청에 따라 복잡한 임시저장 시스템을 제거하고 간단한 로그인 기반 예약 시스템으로 변경:

1. ✅ **BookingForm 수정**: 미로그인 시 바로 로그인 페이지로 리디렉션
2. ✅ **ServiceDetailClient 수정**: 임시 데이터 복원 로직 제거
3. ✅ **로그인 플로우**: returnUrl 파라미터로 로그인 후 원래 페이지로 복귀
4. ✅ **UX 개선**: "로그인이 필요합니다" 알림 후 바로 로그인 페이지 이동
5. ✅ **예약하기 버튼 개선**: 미로그인 시 폼 펼치기 대신 바로 로그인 페이지 이동

**새로운 간단한 플로우**:
```
1. 사용자가 서비스 페이지 방문
2. 날짜/시간 선택
3. '예약하기' 버튼 클릭
   ├─ 로그인됨 → 예약 폼 표시 → 정보 입력 → 예약 완료
   └─ 미로그인 → 로그인 페이지 이동 → 로그인 완료 → 원래 페이지 복귀
``` 

**기존 완료된 작업**:
1. ✅ **무한루프 문제 해결**: 기존 코드 검증 및 모듈 에러 해결
2. ✅ **캘린더 통합 완료**: `ServiceDetailClient`에 `Calendar` 컴포넌트 추가
3. ✅ **날짜-시간 연동**: `useReservationStore`와 완전 연동
4. ✅ **시간 선택 자동화**: 1시간 자동 선택 및 연속 슬롯 로직 개선
5. ✅ **반응형 최적화**: 모바일/데스크톱 환경별 최적화 완료

**새로운 요구사항 분석 결과**:

### 📋 현재 시스템 분석
1. **예약 상태 관리**: `useReservationStore` (Zustand 기반)
   - `selectedDate`: 선택된 날짜
   - `selectedTimeRange`: 시간 범위 (start, end, duration, price)
   - 상태는 메모리에만 저장 (페이지 새로고침 시 초기화)

2. **예약 폼 데이터**: `useBookingFormStore` (Zustand 기반)
   - `customerName`, `companyName`, `shootingPurpose`, `vehicleNumber`
   - `privacyAgreed`: 개인정보 동의 여부
   - 최근 예약 정보 자동 로드 기능 있음

3. **로그인 시스템**: Supabase Auth + AuthContext
   - 로그인 페이지: `/auth/login`
   - 로그인 후 리디렉션: 관리자 → `/admin/reservations`, 일반 사용자 → `/service/pronto-b`

4. **예약 완료 버튼**: `BookingForm.tsx`의 `handleCompleteBooking` 함수
   - 현재 로그인 상태 확인 후 바로 예약 생성
   - 미로그인 시 에러 메시지만 표시

### 🎯 최적 임시 저장 방식 결정

**선택된 방식**: **Hybrid 접근법 (서버 + 클라이언트)**

1. **비개인정보 (sessionStorage)**:
   - `selectedDate`, `selectedTimeRange` (날짜, 시간, 가격)
   - `serviceId` (서비스 식별자)
   - 장점: 빠른 복원, 서버 부하 없음

2. **개인정보 (서버 임시 저장)**:
   - `customerName`, `companyName`, `shootingPurpose`, `vehicleNumber`
   - 암호화하여 Supabase 임시 테이블에 저장
   - 30분 TTL (Time To Live)

3. **연결 키**: UUID 기반 임시 저장 ID
   - sessionStorage에 저장하여 서버 데이터와 연결
   - 로그인 후 복원 시 사용

### 🔐 보안 및 개인정보 보호 강화

1. **암호화 방식**: AES-256-GCM
   - 개인정보 필드별 개별 암호화
   - 암호화 키는 환경변수로 관리

2. **데이터 분류**:
   - **Level 1 (공개)**: serviceId, selectedDate, duration, price
   - **Level 2 (민감)**: customerName, companyName
   - **Level 3 (고민감)**: shootingPurpose, vehicleNumber

3. **자동 삭제**:
   - 30분 후 자동 삭제
   - 로그인 완료 시 즉시 삭제
   - 일일 배치로 만료된 데이터 정리

### 🔄 사용자 플로우 설계

```
1. 사용자가 예약 정보 입력
2. '예약완료 및 결제하기' 클릭
3. 로그인 상태 확인
   ├─ 로그인됨 → 기존 플로우 (예약 생성)
   └─ 미로그인 → 임시 저장 플로우
4. 임시 저장 실행
   ├─ 비개인정보 → sessionStorage
   └─ 개인정보 → 서버 (암호화)
5. 로그인 페이지로 리디렉션 (returnUrl 포함)
6. 로그인 완료
7. 원래 서비스 페이지로 복귀
8. 임시 데이터 자동 복원
9. 복원 완료 알림
10. '예약완료 및 결제하기' 재클릭 → 예약 생성
```

**다음 단계**: Phase 1-1 임시 저장 데이터 스키마 설계부터 시작

## Executor's Feedback or Assistance Requests

**🎯 새로운 핵심 요구사항 분석 완료!**

**요구사항 요약**:
서비스 페이지에서 로그인이 안된 상태에서 '예약완료 및 결제하기' 버튼을 누르면:
1. 기존 예약정보를 임시 저장
2. 로그인 페이지로 이동
3. 로그인 완료 후 서비스 페이지로 리디렉션
4. 임시저장된 정보로 다시 예약 진행

**현재 시스템 분석 완료**:
- ✅ 예약 상태: `useReservationStore` (날짜, 시간, 가격)
- ✅ 폼 데이터: `useBookingFormStore` (개인정보)
- ✅ 로그인 시스템: Supabase Auth + `/auth/login`
- ✅ 예약 버튼: `BookingForm.tsx`의 `handleCompleteBooking`

**최적 임시 저장 방식 결정**:
- 🔒 **개인정보**: 서버에 암호화 저장 (30분 TTL)
- 💾 **비개인정보**: sessionStorage에 저장
- 🔑 **연결 키**: UUID로 서버-클라이언트 데이터 연결

**보안 강화 계획**:
- 🛡️ AES-256-GCM 암호화
- 📊 데이터 민감도별 분류 (Level 1-3)
- ⏰ 자동 삭제 (30분 TTL + 즉시 삭제)

**사용자 플로우 설계 완료**:
10단계 완전한 플로우 정의 완료

**요청사항**: 
이제 **Executor** 모드로 전환하여 Phase 1-1 "임시 저장 데이터 스키마 설계"부터 단계별로 구현을 시작해주세요!

**우선순위**: 
1. 임시 저장 테이블 스키마 설계
2. 암호화 유틸리티 구현
3. 클라이언트 임시 저장 로직
4. 로그인 플로우 통합

**기대 결과**: 
안정적이고 보안이 강화된 예약 정보 임시 저장 시스템으로 사용자 경험 대폭 개선!

---

**🚀 Executor 모드 시작! Phase 1-1 임시 저장 데이터 스키마 설계**

**작업 시작**: 2024년 Phase 1-1 임시 저장 데이터 스키마 설계
**목표**: 예약 정보 임시 저장을 위한 완전한 데이터 스키마 정의

**현재 작업 중**: Phase 1-1 임시 저장 데이터 스키마 설계
- [x] 현재 예약 정보 구조 분석 (`useReservationStore` 분석) ✅
- [x] 개인정보/비개인정보 분류 및 보안 등급 설정 ✅
- [x] 임시 저장 테이블 스키마 설계 ✅
- [x] 암호화 필요 필드 식별 및 암호화 방식 결정 ✅

**Phase 1-1 완료! 🎉**

**완료된 작업**:
1. ✅ **타입 정의 완료**: `src/types/tempStorage.ts` - 완전한 타입 시스템 구축
2. ✅ **데이터베이스 스키마**: `supabase/migrations/0003_temp_reservation_storage.sql` - 보안 테이블 생성
3. ✅ **암호화 유틸리티**: `src/lib/encryption.ts` - AES-256-GCM 암호화 시스템

**데이터 분류 완료**:
- 📊 **Level 1 (공개)**: `serviceId`, `selectedDate`, `selectedTimeRange` → sessionStorage
- 🔒 **Level 2 (민감)**: `customerName`, `companyName` → 서버 암호화 저장
- 🔐 **Level 3 (고민감)**: `shootingPurpose`, `vehicleNumber` → 서버 암호화 저장

**보안 기능 구현**:
- 🛡️ AES-256-GCM 암호화
- 🔍 SHA-256 무결성 검증
- ⏰ 30분 TTL 자동 만료
- 🗂️ 자동 배치 정리 시스템

**다음 작업**: Phase 1-2 임시 저장 API 구현 시작
- [ ] 임시 저장 API 엔드포인트 구현 (`/api/temp-storage`)
- [ ] 데이터 복원 API 구현
- [ ] 클라이언트 sessionStorage 관리자
- [ ] 에러 처리 및 로깅 시스템

---

**🚀 Phase 1-2 시작: 임시 저장 API 구현**

**작업 목표**: 예약 정보 임시 저장을 위한 완전한 API 시스템 구축

**현재 작업 중**: Phase 1-2 임시 저장 API 구현
- [x] 임시 저장 API 엔드포인트 구현 (`/api/temp-storage`) ✅
- [x] 데이터 복원 API 구현 (`/api/temp-storage/restore`) ✅
- [x] 클라이언트 sessionStorage 관리자 (`tempStorageManager.ts`) ✅
- [x] 에러 처리 및 로깅 시스템 (`tempStorageErrors.ts`) ✅

**Phase 1-2 완료! 🎉**

**완료된 작업**:
1. ✅ **임시 저장 API**: POST/DELETE 엔드포인트 구현 - 암호화 저장/삭제
2. ✅ **데이터 복원 API**: POST/GET 엔드포인트 구현 - 복호화 복원/상태 확인
3. ✅ **클라이언트 관리자**: TempStorageManager 클래스 - sessionStorage 연동
4. ✅ **에러 처리 시스템**: TempStorageException, 로거, 재시도 로직

**핵심 기능 구현 완료**:
- 🔐 **암호화 시스템**: AES-256-GCM + SHA-256 무결성 검증
- 📦 **하이브리드 저장**: 개인정보(서버) + 비개인정보(sessionStorage)
- 🔄 **자동 복원**: 로그인 후 데이터 복원 및 상태 복구
- ⚠️ **견고한 에러 처리**: 사용자 친화적 메시지 + 재시도 로직

---

**🚀 Phase 2-1 시작: 기존 예약 시스템과 통합**

**작업 목표**: BookingForm과 예약 스토어를 임시 저장 시스템과 연동

**현재 작업 중**: Phase 2-1 예약 시스템 통합
- [x] BookingForm의 handleCompleteBooking 수정 (미로그인 시 임시 저장) ✅
- [x] 서비스 페이지에 복원 로직 추가 (로그인 후 자동 복원) ✅
- [x] 예약 스토어 연동 (useReservationStore + useBookingFormStore) ✅
- [ ] 사용자 알림 및 피드백 시스템

**Phase 2-1 거의 완료! 🎉**

**완료된 통합 작업**:
1. ✅ **BookingForm 통합**: 미로그인 시 임시 저장 후 로그인 페이지 리디렉션
2. ✅ **ServiceDetailClient 통합**: 로그인 후 자동 데이터 복원 및 상태 복구
3. ✅ **스토어 연동**: useReservationStore + useBookingFormStore 완전 연동

**핵심 통합 기능**:
- 🔄 **seamless 플로우**: 예약정보 입력 → 임시저장 → 로그인 → 자동복원 → 예약완료
- 📱 **사용자 친화적**: 로그인 전후 데이터 손실 없음
- 🎯 **스마트 매칭**: 서비스 ID 검증으로 올바른 서비스 페이지에서만 복원
- ⚡ **즉시 복원**: 로그인 완료 시 즉시 예약 상태 복구

**남은 작업**: 
- [ ] 사용자 알림 및 피드백 시스템 (토스트, 로딩 상태, 에러 처리)

---

**🚀 Phase 2-2 시작: 사용자 알림 및 피드백 시스템**

**작업 목표**: 전체 플로우에서 사용자 경험 개선을 위한 알림 시스템 구축

**현재 작업 중**: Phase 2-2 사용자 피드백 시스템
- [x] 임시 저장 중 로딩 상태 및 진행률 표시 ✅
- [x] 복원 성공/실패 토스트 메시지 개선 ✅
- [x] 에러 상황별 사용자 가이드 메시지 ✅
- [x] Linter 오류 수정 (토스트 훅 위치 수정) ✅
- [ ] 최종 통합 테스트 및 시나리오 검증

**Phase 2-2 거의 완료! 🎉**

**완료된 사용자 경험 개선**:
1. ✅ **토스트 메시지 개선**: 임시 저장/복원 시 더 직관적이고 구체적인 알림
2. ✅ **로딩 상태 개선**: 스피너 + 상황별 메시지 (임시저장 vs 예약생성)
3. ✅ **에러 처리 강화**: 암호화, 네트워크, 저장 오류별 구체적 가이드
4. ✅ **개발자 친화적**: 개발 환경에서만 복원 실패 알림 표시
5. ✅ **중복 토스트 방지**: 임시 저장 성공 알림 제거로 깔끔한 플로우

**사용자 경험 플로우**:
- 📦 **임시 저장**: "예약 정보 저장 중..." → 자동 리디렉션
- 🎉 **복원 완료**: "홍길동님의 예약 정보가 복원되었습니다" + 폼 자동 열기
- ⚡ **로딩**: 스피너 + 상황별 메시지
- ❌ **에러**: 구체적인 문제점 + 해결 가이드

**다음 작업**: 최종 통합 테스트 및 전체 시나리오 검증

---

**🚨 긴급 버그 수정: 이미지 무한로딩 문제 해결**

**문제 발견**: `StudioImageGallery.tsx`에서 이미지 404 오류 시 무한루프 발생
- **원인**: `onError` 핸들러에서 같은 404 이미지로 재설정하여 무한 재시도
- **증상**: `GET /images/studios/{id}/default?w=600 404` 무한 반복

**해결 방법**:
1. ✅ **실패 상태 관리**: `failedImages` Set으로 실패한 이미지 URL 추적
2. ✅ **플레이스홀더 이미지**: Unsplash 기반 안정적인 대체 이미지 사용
3. ✅ **재시도 방지**: 이미 플레이스홀더인 경우 추가 처리 방지
4. ✅ **전체 갤러리 적용**: 메인 이미지, 썸네일, 모달 이미지 모두 적용

**기술적 개선**:
- 🔄 **상태 기반 이미지 관리**: `useMemo`에서 실패 상태 반영
- 🖼️ **반응형 플레이스홀더**: 크기별 최적화된 이미지 제공
- 🛡️ **안전한 에러 처리**: 무한루프 방지 로직 추가

**결과**: 이미지 로딩 실패 시에도 안정적인 사용자 경험 제공

# Pronto 4-1단계: 운영자 휴무일 설정 기능 구현 계획

## Background and Motivation

**핵심 요구사항**: 운영자가 특정 날짜나 요일을 휴무일로 지정하여 예약 불가능하게 만드는 기능을 구현해야 합니다. 이는 Pronto 서비스 단계별 개발 계획 v8.9의 Phase 4-1단계에 해당하는 기능입니다.

**현재 상황**:
- ✅ holidays 테이블 마이그레이션 SQL 생성 완료 (0016_create_holidays_table.sql)
- ✅ 관리자 서비스 관리 페이지에 휴무일 설정 UI가 이미 구현되어 있음 (`/admin/services`)
- ✅ 예약 가능 시간 API에서 holidays 테이블 반영 로직이 이미 구현되어 있음
- ✅ 운영자 휴무일 설정 UI를 모바일 우선 1열 레이아웃으로 개선 완료
- ✅ 캘린더를 테이블 형식으로 변경하여 정렬 문제 해결 완료
- 🔄 고객용 캘린더에서 휴무일 미리 표시 기능 구현 중

**기술적 배경**: 
- holidays 테이블: service_id, holiday_date, description, created_at, updated_at
- 예약 가능 시간 API: `/api/services/[serviceId]/available-times/route.ts`에서 이미 holidays 테이블을 조회하는 로직이 구현되어 있음
- 관리자 페이지: `/admin/services`에서 휴무일 설정 기능이 이미 구현되어 있음

## Key Challenges and Analysis

### 1. 현재 구현 상태 분석 ✅ **완료**
- **예약 가능 시간 API**: 이미 holidays 테이블을 조회하여 휴무일 처리 로직이 구현되어 있음
- **관리자 UI**: `/admin/services` 페이지에 휴무일 설정 기능이 이미 구현되어 있음
- **필요한 작업**: 기존 구현의 완성도 검토 및 UI 개선

### 2. UI/UX 개선 필요사항 ✅ **완료**
- **모바일 우선 디자인**: 기존 2열 그리드에서 1열 레이아웃으로 변경
- **휴무일 목록 표시**: 테이블 형태에서 카드 형태로 변경하여 모바일에서 더 사용하기 편하게 개선
- **시각적 개선**: 섹션별 구분을 명확히 하고 폰트 크기 조정

### 3. 캘린더 정렬 문제 해결 ✅ **완료**
- **문제**: 기존 `DayPicker` 컴포넌트가 좌측으로 쏠려있어 컨테이너 내에서 정렬이 맞지 않음
- **해결책**: 커스텀 `Calendar` 컴포넌트로 교체하여 테이블 형식으로 변경
- **개선점**: 
  - 중앙 정렬된 캘린더 레이아웃
  - 일관된 테이블 구조로 모바일에서 더 예측 가능한 UI
  - 기존 프로젝트의 다른 Calendar 컴포넌트와 일관성 유지

### 4. 고객용 캘린더 휴무일 미리 표시 🔄 **진행 중**
- **현재 문제**: 고객이 휴무일을 선택한 후에야 휴무일임을 알 수 있음
- **개선 목표**: 캘린더에서 휴무일을 미리 시각적으로 표시
- **필요 작업**:
  - 월별 휴무일 정보를 미리 로드하는 API 구현
  - 고객용 캘린더에서 휴무일 스타일링 적용
  - 휴무일 선택 방지 또는 명확한 표시

## High-level Task Breakdown

### Task 1: 기존 구현 상태 확인 및 분석 ✅ **완료**
**목표**: 현재 휴무일 설정 기능의 구현 상태를 정확히 파악
**성공 기준**: 
- holidays 테이블 스키마 확인 완료
- 예약 가능 시간 API에서 휴무일 반영 로직 확인 완료
- 관리자 UI 기능 확인 완료

**결과**: 
- holidays 테이블이 이미 생성되어 있음 (0016_create_holidays_table.sql)
- 예약 가능 시간 API에서 holidays 테이블 조회 로직이 구현되어 있음
- 관리자 페이지에서 휴무일 설정/삭제 기능이 모두 구현되어 있음

### Task 2: 휴무일 설정 UI 모바일 우선 개선 ✅ **완료**
**목표**: 기존 2열 그리드 레이아웃을 모바일 우선 1열 레이아웃으로 변경
**성공 기준**:
- 휴무일 설정과 등록된 휴무일 목록이 세로로 배치됨
- 등록된 휴무일 목록이 테이블에서 카드 형태로 변경됨
- 모바일에서 사용하기 편한 UI로 개선됨

**결과**:
- ✅ 2열 그리드(`grid-cols-1 md:grid-cols-2`)를 1열 레이아웃(`space-y-8`)으로 변경
- ✅ 휴무일 목록을 테이블에서 카드 형태로 변경
- ✅ 각 섹션의 제목 크기를 `text-lg`로 확대하여 가독성 향상
- ✅ 휴무일 카드에 적절한 패딩과 간격 적용
- ✅ 오늘 날짜와 과거 날짜에 대한 시각적 구분 유지

### Task 3: 캘린더 테이블 형식 변경 ✅ **완료**
**목표**: 기존 DayPicker를 커스텀 Calendar 컴포넌트로 교체하여 정렬 문제 해결
**성공 기준**:
- 캘린더가 컨테이너 내에서 중앙 정렬됨
- 테이블 형식으로 일관된 레이아웃 제공
- 휴무일 표시 기능 유지

**결과**:
- ✅ `DayPicker` → 커스텀 `Calendar` 컴포넌트로 교체
- ✅ `flex justify-center`로 캘린더 중앙 정렬
- ✅ `modifiersClassNames`로 휴무일 스타일링 (빨간색 배경)
- ✅ 과거 날짜 선택 방지 기능 유지
- ✅ 다중 날짜 선택 기능 유지

### Task 4: 고객용 캘린더 휴무일 미리 표시 🔄 **진행 중**
**목표**: 고객이 캘린더에서 휴무일을 미리 확인할 수 있도록 개선
**성공 기준**:
- 월별 휴무일 정보를 미리 로드하는 API 구현
- 고객용 캘린더에서 휴무일이 시각적으로 구분됨
- 휴무일 선택 시 명확한 안내 메시지 제공

**세부 작업**:
1. **월별 휴무일 조회 API 구현**
   - `/api/services/[serviceId]/holidays?year=YYYY&month=MM` 엔드포인트 생성
   - 특정 월의 모든 휴무일 정보 반환
   
2. **고객용 캘린더 컴포넌트 개선**
   - `ServiceDetailClient`의 `Calendar` 컴포넌트에 휴무일 정보 연동
   - 휴무일 스타일링 적용 (회색 배경, "휴무" 라벨 등)
   - 휴무일 선택 방지 또는 명확한 표시

3. **휴무일 정보 캐싱 및 성능 최적화**
   - React Query를 활용한 휴무일 정보 캐싱
   - 월 변경 시 자동으로 해당 월 휴무일 정보 로드

## Project Status Board

### 완료된 작업
- [x] holidays 테이블 마이그레이션 SQL 확인
- [x] 예약 가능 시간 API의 휴무일 반영 로직 확인  
- [x] 관리자 휴무일 설정 UI 확인
- [x] 휴무일 설정 UI를 모바일 우선 1열 레이아웃으로 개선
- [x] 휴무일 목록을 카드 형태로 변경하여 모바일 친화적으로 개선
- [x] 캘린더를 테이블 형식으로 변경하여 정렬 문제 해결

### 완료된 작업 (Task 4) ✅
- [x] **Task 4-1: 월별 휴무일 조회 API 구현** ✅
  - [x] `/api/services/[serviceId]/holidays` 엔드포인트 생성
  - [x] 년/월 파라미터로 해당 월의 모든 휴무일 정보 반환
  - [x] 캐싱 헤더 설정 (1시간 캐시, stale-while-revalidate)

- [x] **Task 4-2: 고객용 캘린더 휴무일 표시** ✅
  - [x] `ServiceDetailClient`에서 휴무일 정보 로드 (React Query 사용)
  - [x] `Calendar` 컴포넌트에 휴무일 modifiers 적용
  - [x] 휴무일 스타일링 (회색 배경, 취소선, 선택 불가)
  - [x] 휴무일 안내 범례 추가

- [x] **Task 4-3: 사용자 경험 개선** ✅
  - [x] 휴무일 선택 시 토스트 안내 메시지
  - [x] 휴무일 정보 캐싱 및 성능 최적화 (React Query, 5분 stale time)
  - [x] 월 변경 시 자동 휴무일 정보 로드

### 현재 상태
**4-1단계 운영자 휴무일 설정 기능 구현이 완전히 완료되었습니다!** ✅

모든 핵심 기능이 이미 구현되어 있었으며, 사용자 요청에 따라 UI를 모바일 우선 디자인으로 개선하고 캘린더 정렬 문제를 해결하였습니다. 추가로 고객용 캘린더에서 휴무일을 미리 표시하는 기능까지 완전히 구현하여 사용자 경험을 크게 향상시켰습니다.

## Current Status / Progress Tracking

**현재 진행 상황**: 4-1단계 완전 완료! ✅

**완료된 기능들**:
1. ✅ holidays 테이블 스키마 및 마이그레이션
2. ✅ 예약 가능 시간 API에서 휴무일 정보 반영
3. ✅ 관리자 페이지에서 휴무일 설정/삭제 기능
4. ✅ 모바일 우선 UI 개선 (1열 레이아웃, 카드 형태 목록)
5. ✅ 캘린더 테이블 형식 변경 및 정렬 문제 해결
6. ✅ 고객용 캘린더에서 휴무일 미리 표시 기능 구현

**최신 완료 작업**:
- ✅ 월별 휴무일 조회 API 구현 (`/api/services/[serviceId]/holidays`)
- ✅ 고객용 캘린더에 휴무일 시각적 표시 (회색 배경, 취소선)
- ✅ 휴무일 선택 방지 및 토스트 안내 메시지
- ✅ React Query를 활용한 휴무일 정보 캐싱 및 성능 최적화

**최신 개선 사항**:
- **캘린더 정렬 문제 해결**: `DayPicker` → 커스텀 `Calendar` 컴포넌트로 교체
- **중앙 정렬**: `flex justify-center`로 캘린더가 컨테이너 내에서 완벽하게 중앙 정렬
- **일관된 디자인**: 프로젝트의 다른 Calendar 컴포넌트와 동일한 테이블 구조 사용
- ⚡ **즉시 복원**: 로그인 완료 시 즉시 예약 상태 복구

**완료된 모든 작업**: 
- ✅ Task 4-1: 월별 휴무일 조회 API 구현
- ✅ Task 4-2: 고객용 캘린더 휴무일 표시
- ✅ Task 4-3: 사용자 경험 개선

**다음 단계**: 4-1단계가 완전히 완료되었으므로, 사용자 테스트 및 다음 단계 계획 수립

## Lessons

### 기존 구현 확인의 중요성
- 새로운 기능을 구현하기 전에 기존 코드베이스를 철저히 확인하는 것이 중요함
- 이번 경우 holidays 테이블과 관련 로직이 이미 완전히 구현되어 있었음

### 모바일 우선 디자인 원칙
- 테이블 형태의 데이터 표시는 모바일에서 불편할 수 있음
- 카드 형태로 변경하면 모바일에서 더 나은 사용자 경험 제공 가능
- `space-y-*` 클래스를 활용한 세로 레이아웃이 모바일에서 효과적임

### 캘린더 컴포넌트 선택의 중요성
- 기본 `DayPicker` 컴포넌트는 정렬 문제가 발생할 수 있음
- 커스텀 `Calendar` 컴포넌트를 사용하면 더 일관된 레이아웃과 스타일링 제공
- 테이블 형식의 캘린더가 컨테이너 내에서 더 예측 가능한 정렬을 제공함
- 프로젝트 내 컴포넌트 일관성을 유지하는 것이 중요함

### 사용자 경험 우선 설계
- 기능이 작동하는 것과 사용자가 직관적으로 이해할 수 있는 것은 다름
- 휴무일 기능이 완벽히 작동하더라도 고객이 미리 알 수 없다면 UX 개선이 필요
- 정보를 미리 표시하는 것이 사후 안내보다 훨씬 나은 사용자 경험 제공