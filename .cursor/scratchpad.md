# Pronto 관리자 로그인 리디렉션 문제 해결 계획

## Background and Motivation

**핵심 문제**: 관리자 계정으로 로그인 시 Header에 '관리자' 아이콘은 표시되지만, 관리자 페이지로 리디렉션이 되지 않는 문제가 지속되고 있습니다. 또한 직접 URL로 `/admin/reservations` 접근 시 로그인 페이지로 리디렉션되는 문제도 발생하고 있습니다.

**기술적 배경**: 이는 클라이언트 사이드 세션 관리(localStorage 기반)와 서버 사이드 미들웨어(HTTP 쿠키 기반) 간의 세션 불일치 문제로 확인되었습니다. Supabase 세션이 localStorage에만 저장되고 HTTP 쿠키로는 전달되지 않아, 미들웨어에서 세션을 읽지 못하는 상황입니다.

---

# 🚨 새로운 긴급 문제: 서비스 페이지 무한루프 및 캘린더/시간슬라이더 구현 문제

## Background and Motivation

**핵심 문제**: 
1. `http://localhost:3001/service/pronto-b` 페이지에서 무한루프가 발생하고 있음
2. 캘린더와 시간슬라이더가 제대로 구현되어 있지 않음
3. 이전에 만들었던 캘린더/시간슬라이더 코드를 현재 구조에 맞게 재구현 필요

**기술적 배경**: 
- `TimeRangeSelector` 컴포넌트에서 `useEffect`와 `useCallback`의 의존성 배열 문제로 무한루프 발생
- `ServiceDetailClient`에서 캘린더 컴포넌트가 누락되어 있음
- 기존에 구현된 `Calendar` 컴포넌트와 `MinimalCalendarPage` 예제가 있지만 현재 서비스 페이지에 통합되지 않음

## Key Challenges and Analysis

### 1. 무한루프 문제 분석
- **원인**: `TimeRangeSelector`의 `useEffect` 의존성 배열에 `toast` 함수가 포함되어 있어 매 렌더링마다 실행됨
- **영향**: API 호출 → 상태 업데이트 → 재렌더링 → 다시 API 호출의 무한 반복
- **해결 필요**: `useEffect`와 `useCallback`의 의존성 배열 최적화

### 2. 캘린더 구현 누락
- **현재 상태**: `ServiceDetailClient`에서 캘린더 컴포넌트가 없음
- **기존 자산**: `Calendar` 컴포넌트와 `MinimalCalendarPage` 예제가 이미 구현되어 있음
- **필요 작업**: 기존 캘린더를 현재 예약 시스템에 통합

### 3. 시간슬라이더 개선 필요
- **현재 상태**: `TimeRangeSelector`가 구현되어 있지만 무한루프 문제와 UX 개선 필요
- **기존 자산**: `TimeSlotGrid` 컴포넌트와 시간 선택 로직이 구현되어 있음
- **필요 작업**: 무한루프 해결 및 사용자 경험 개선

## High-level Task Breakdown

### Phase 1: 무한루프 문제 해결 🔥
1. **TimeRangeSelector useEffect 의존성 배열 수정**
   - `toast` 함수를 의존성 배열에서 제거
   - `useCallback` 의존성 배열 최적화
   - 성공 기준: 무한루프 없이 정상적인 API 호출

2. **handleSlotClick useCallback 최적화**
   - 불필요한 의존성 제거
   - 메모이제이션 최적화
   - 성공 기준: 시간 슬롯 클릭 시 정상 동작

### Phase 2: 캘린더 통합 구현 📅
3. **기존 Calendar 컴포넌트를 ServiceDetailClient에 통합**
   - `Calendar` 컴포넌트를 예약 시스템에 연결
   - `useReservationStore`와 연동
   - 성공 기준: 날짜 선택 시 시간 슬롯 업데이트

4. **캘린더와 시간슬라이더 연동**
   - 날짜 변경 시 시간 슬롯 자동 업데이트
   - 선택 상태 동기화
   - 성공 기준: 캘린더-시간슬라이더 완전 연동

### Phase 3: UX 개선 및 최적화 ✨
5. **시간 선택 자동화 기능 구현**
   - 최초 선택 시 1시간 자동 선택
   - 연속 슬롯 선택 로직 개선
   - 성공 기준: 직관적인 시간 선택 경험

6. **반응형 레이아웃 최적화**
   - 모바일/데스크톱 최적화
   - 캘린더와 시간슬라이더 배치 개선
   - 성공 기준: 모든 디바이스에서 원활한 사용

### Phase 4: 통합 테스트 및 검증 🧪
7. **전체 예약 플로우 테스트**
   - 날짜 선택 → 시간 선택 → 예약 정보 입력 플로우
   - 다양한 시나리오 테스트
   - 성공 기준: 완전한 예약 플로우 동작

8. **성능 최적화 및 오류 처리**
   - API 호출 최적화
   - 에러 상황 처리 개선
   - 성공 기준: 안정적이고 빠른 예약 시스템

## Project Status Board

### 🔥 긴급 해결 필요 (Phase 1)
- [x] **Phase 1-1: TimeRangeSelector useEffect 의존성 배열 수정**
  - [x] `toast` 함수를 의존성 배열에서 제거 (이미 올바르게 설정됨)
  - [x] API 호출 로직 최적화 확인
  - [x] 무한루프 해결 확인

- [x] **Phase 1-2: handleSlotClick useCallback 최적화**
  - [x] 불필요한 의존성 제거 (이미 올바르게 설정됨)
  - [x] 메모이제이션 최적화 확인
  - [x] 시간 슬롯 클릭 정상 동작 확인

### 📅 캘린더 구현 (Phase 2)
- [x] **Phase 2-1: 기존 Calendar 컴포넌트 통합**
  - [x] ServiceDetailClient에 Calendar 컴포넌트 추가
  - [x] useReservationStore와 연동
  - [x] 날짜 선택 시 상태 업데이트 확인

- [x] **Phase 2-2: 캘린더-시간슬라이더 연동**
  - [x] 날짜 변경 시 시간 슬롯 업데이트 테스트 ✅
  - [x] 선택 상태 동기화 확인 ✅
  - [x] 완전한 연동 동작 확인 ✅

### ✨ UX 개선 (Phase 3) - 완료
- [x] **Phase 3-1: 시간 선택 자동화**
  - [x] 최초 시간 선택 시 1시간 자동 선택 구현 ✅
  - [x] 연속 슬롯 선택 로직 개선 ✅
  - [x] 직관적인 시간 선택 경험 제공 ✅
  - [x] 사용자 피드백 토스트 메시지 추가 ✅

- [x] **Phase 3-2: 반응형 레이아웃 최적화**
  - [x] 모바일 환경 최적화 ✅
  - [x] 데스크톱 환경 최적화 ✅
  - [x] 캘린더와 시간슬라이더 배치 개선 ✅
  - [x] 터치 인터랙션 개선 ✅

### 🧪 테스트 및 검증 (Phase 4) - 진행 중
- [ ] **Phase 4-1: 전체 예약 플로우 테스트**
  - [ ] 날짜 선택 → 시간 선택 → 예약 정보 입력 플로우 테스트
  - [ ] 다양한 시나리오 테스트 (연속/비연속 시간 선택)
  - [ ] 에러 상황 처리 테스트
  - [ ] 모바일/데스크톱 환경 테스트

- [ ] **Phase 4-2: 성능 최적화 및 마무리**
  - [ ] API 호출 최적화 확인
  - [ ] 메모리 누수 방지 확인
  - [ ] 접근성 개선
  - [ ] 최종 코드 정리

### ✅ 완료된 작업들 (이전 관리자 로그인 문제)
- [x] **Phase 1-1: createServerClient와 createBrowserClient 설정 통합**
- [x] **Phase 1-2: 미들웨어 쿠키 처리 로직 개선**

## Current Status / Progress Tracking

**현재 상태**: 🎯 **임시저장 로직 제거 완료 - 간단한 로그인 기반 예약 시스템**

**⚡ 최신 변경사항 (2024년 12월)**:
사용자 요청에 따라 복잡한 임시저장 시스템을 제거하고 간단한 로그인 기반 예약 시스템으로 변경:

1. ✅ **BookingForm 수정**: 미로그인 시 바로 로그인 페이지로 리디렉션
2. ✅ **ServiceDetailClient 수정**: 임시 데이터 복원 로직 제거
3. ✅ **로그인 플로우**: returnUrl 파라미터로 로그인 후 원래 페이지로 복귀
4. ✅ **UX 개선**: "로그인이 필요합니다" 알림 후 바로 로그인 페이지 이동
5. ✅ **예약하기 버튼 개선**: 미로그인 시 폼 펼치기 대신 바로 로그인 페이지 이동

**새로운 간단한 플로우**:
```
1. 사용자가 서비스 페이지 방문
2. 날짜/시간 선택
3. '예약하기' 버튼 클릭
   ├─ 로그인됨 → 예약 폼 표시 → 정보 입력 → 예약 완료
   └─ 미로그인 → 로그인 페이지 이동 → 로그인 완료 → 원래 페이지 복귀
``` 

**기존 완료된 작업**:
1. ✅ **무한루프 문제 해결**: 기존 코드 검증 및 모듈 에러 해결
2. ✅ **캘린더 통합 완료**: `ServiceDetailClient`에 `Calendar` 컴포넌트 추가
3. ✅ **날짜-시간 연동**: `useReservationStore`와 완전 연동
4. ✅ **시간 선택 자동화**: 1시간 자동 선택 및 연속 슬롯 로직 개선
5. ✅ **반응형 최적화**: 모바일/데스크톱 환경별 최적화 완료

**새로운 요구사항 분석 결과**:

### 📋 현재 시스템 분석
1. **예약 상태 관리**: `useReservationStore` (Zustand 기반)
   - `selectedDate`: 선택된 날짜
   - `selectedTimeRange`: 시간 범위 (start, end, duration, price)
   - 상태는 메모리에만 저장 (페이지 새로고침 시 초기화)

2. **예약 폼 데이터**: `useBookingFormStore` (Zustand 기반)
   - `customerName`, `companyName`, `shootingPurpose`, `vehicleNumber`
   - `privacyAgreed`: 개인정보 동의 여부
   - 최근 예약 정보 자동 로드 기능 있음

3. **로그인 시스템**: Supabase Auth + AuthContext
   - 로그인 페이지: `/auth/login`
   - 로그인 후 리디렉션: 관리자 → `/admin/reservations`, 일반 사용자 → `/service/pronto-b`

4. **예약 완료 버튼**: `BookingForm.tsx`의 `handleCompleteBooking` 함수
   - 현재 로그인 상태 확인 후 바로 예약 생성
   - 미로그인 시 에러 메시지만 표시

### 🎯 최적 임시 저장 방식 결정

**선택된 방식**: **Hybrid 접근법 (서버 + 클라이언트)**

1. **비개인정보 (sessionStorage)**:
   - `selectedDate`, `selectedTimeRange` (날짜, 시간, 가격)
   - `serviceId` (서비스 식별자)
   - 장점: 빠른 복원, 서버 부하 없음

2. **개인정보 (서버 임시 저장)**:
   - `customerName`, `companyName`, `shootingPurpose`, `vehicleNumber`
   - 암호화하여 Supabase 임시 테이블에 저장
   - 30분 TTL (Time To Live)

3. **연결 키**: UUID 기반 임시 저장 ID
   - sessionStorage에 저장하여 서버 데이터와 연결
   - 로그인 후 복원 시 사용

### 🔐 보안 및 개인정보 보호 강화

1. **암호화 방식**: AES-256-GCM
   - 개인정보 필드별 개별 암호화
   - 암호화 키는 환경변수로 관리

2. **데이터 분류**:
   - **Level 1 (공개)**: serviceId, selectedDate, duration, price
   - **Level 2 (민감)**: customerName, companyName
   - **Level 3 (고민감)**: shootingPurpose, vehicleNumber

3. **자동 삭제**:
   - 30분 후 자동 삭제
   - 로그인 완료 시 즉시 삭제
   - 일일 배치로 만료된 데이터 정리

### 🔄 사용자 플로우 설계

```
1. 사용자가 예약 정보 입력
2. '예약완료 및 결제하기' 클릭
3. 로그인 상태 확인
   ├─ 로그인됨 → 기존 플로우 (예약 생성)
   └─ 미로그인 → 임시 저장 플로우
4. 임시 저장 실행
   ├─ 비개인정보 → sessionStorage
   └─ 개인정보 → 서버 (암호화)
5. 로그인 페이지로 리디렉션 (returnUrl 포함)
6. 로그인 완료
7. 원래 서비스 페이지로 복귀
8. 임시 데이터 자동 복원
9. 복원 완료 알림
10. '예약완료 및 결제하기' 재클릭 → 예약 생성
```

**다음 단계**: Phase 1-1 임시 저장 데이터 스키마 설계부터 시작

## Executor's Feedback or Assistance Requests

**🎯 새로운 핵심 요구사항 분석 완료!**

**요구사항 요약**:
서비스 페이지에서 로그인이 안된 상태에서 '예약완료 및 결제하기' 버튼을 누르면:
1. 기존 예약정보를 임시 저장
2. 로그인 페이지로 이동
3. 로그인 완료 후 서비스 페이지로 리디렉션
4. 임시저장된 정보로 다시 예약 진행

**현재 시스템 분석 완료**:
- ✅ 예약 상태: `useReservationStore` (날짜, 시간, 가격)
- ✅ 폼 데이터: `useBookingFormStore` (개인정보)
- ✅ 로그인 시스템: Supabase Auth + `/auth/login`
- ✅ 예약 버튼: `BookingForm.tsx`의 `handleCompleteBooking`

**최적 임시 저장 방식 결정**:
- 🔒 **개인정보**: 서버에 암호화 저장 (30분 TTL)
- 💾 **비개인정보**: sessionStorage에 저장
- 🔑 **연결 키**: UUID로 서버-클라이언트 데이터 연결

**보안 강화 계획**:
- 🛡️ AES-256-GCM 암호화
- 📊 데이터 민감도별 분류 (Level 1-3)
- ⏰ 자동 삭제 (30분 TTL + 즉시 삭제)

**사용자 플로우 설계 완료**:
10단계 완전한 플로우 정의 완료

**요청사항**: 
이제 **Executor** 모드로 전환하여 Phase 1-1 "임시 저장 데이터 스키마 설계"부터 단계별로 구현을 시작해주세요!

**우선순위**: 
1. 임시 저장 테이블 스키마 설계
2. 암호화 유틸리티 구현
3. 클라이언트 임시 저장 로직
4. 로그인 플로우 통합

**기대 결과**: 
안정적이고 보안이 강화된 예약 정보 임시 저장 시스템으로 사용자 경험 대폭 개선!

---

**🚀 Executor 모드 시작! Phase 1-1 임시 저장 데이터 스키마 설계**

**작업 시작**: 2024년 Phase 1-1 임시 저장 데이터 스키마 설계
**목표**: 예약 정보 임시 저장을 위한 완전한 데이터 스키마 정의

**현재 작업 중**: Phase 1-1 임시 저장 데이터 스키마 설계
- [x] 현재 예약 정보 구조 분석 (`useReservationStore` 분석) ✅
- [x] 개인정보/비개인정보 분류 및 보안 등급 설정 ✅
- [x] 임시 저장 테이블 스키마 설계 ✅
- [x] 암호화 필요 필드 식별 및 암호화 방식 결정 ✅

**Phase 1-1 완료! 🎉**

**완료된 작업**:
1. ✅ **타입 정의 완료**: `src/types/tempStorage.ts` - 완전한 타입 시스템 구축
2. ✅ **데이터베이스 스키마**: `supabase/migrations/0003_temp_reservation_storage.sql` - 보안 테이블 생성
3. ✅ **암호화 유틸리티**: `src/lib/encryption.ts` - AES-256-GCM 암호화 시스템

**데이터 분류 완료**:
- 📊 **Level 1 (공개)**: `serviceId`, `selectedDate`, `selectedTimeRange` → sessionStorage
- 🔒 **Level 2 (민감)**: `customerName`, `companyName` → 서버 암호화 저장
- 🔐 **Level 3 (고민감)**: `shootingPurpose`, `vehicleNumber` → 서버 암호화 저장

**보안 기능 구현**:
- 🛡️ AES-256-GCM 암호화
- 🔍 SHA-256 무결성 검증
- ⏰ 30분 TTL 자동 만료
- 🗂️ 자동 배치 정리 시스템

**다음 작업**: Phase 1-2 임시 저장 API 구현 시작
- [ ] 임시 저장 API 엔드포인트 구현 (`/api/temp-storage`)
- [ ] 데이터 복원 API 구현
- [ ] 클라이언트 sessionStorage 관리자
- [ ] 에러 처리 및 로깅 시스템

---

**🚀 Phase 1-2 시작: 임시 저장 API 구현**

**작업 목표**: 예약 정보 임시 저장을 위한 완전한 API 시스템 구축

**현재 작업 중**: Phase 1-2 임시 저장 API 구현
- [x] 임시 저장 API 엔드포인트 구현 (`/api/temp-storage`) ✅
- [x] 데이터 복원 API 구현 (`/api/temp-storage/restore`) ✅
- [x] 클라이언트 sessionStorage 관리자 (`tempStorageManager.ts`) ✅
- [x] 에러 처리 및 로깅 시스템 (`tempStorageErrors.ts`) ✅

**Phase 1-2 완료! 🎉**

**완료된 작업**:
1. ✅ **임시 저장 API**: POST/DELETE 엔드포인트 구현 - 암호화 저장/삭제
2. ✅ **데이터 복원 API**: POST/GET 엔드포인트 구현 - 복호화 복원/상태 확인
3. ✅ **클라이언트 관리자**: TempStorageManager 클래스 - sessionStorage 연동
4. ✅ **에러 처리 시스템**: TempStorageException, 로거, 재시도 로직

**핵심 기능 구현 완료**:
- 🔐 **암호화 시스템**: AES-256-GCM + SHA-256 무결성 검증
- 📦 **하이브리드 저장**: 개인정보(서버) + 비개인정보(sessionStorage)
- 🔄 **자동 복원**: 로그인 후 데이터 복원 및 상태 복구
- ⚠️ **견고한 에러 처리**: 사용자 친화적 메시지 + 재시도 로직

---

**🚀 Phase 2-1 시작: 기존 예약 시스템과 통합**

**작업 목표**: BookingForm과 예약 스토어를 임시 저장 시스템과 연동

**현재 작업 중**: Phase 2-1 예약 시스템 통합
- [x] BookingForm의 handleCompleteBooking 수정 (미로그인 시 임시 저장) ✅
- [x] 서비스 페이지에 복원 로직 추가 (로그인 후 자동 복원) ✅
- [x] 예약 스토어 연동 (useReservationStore + useBookingFormStore) ✅
- [ ] 사용자 알림 및 피드백 시스템

**Phase 2-1 거의 완료! 🎉**

**완료된 통합 작업**:
1. ✅ **BookingForm 통합**: 미로그인 시 임시 저장 후 로그인 페이지 리디렉션
2. ✅ **ServiceDetailClient 통합**: 로그인 후 자동 데이터 복원 및 상태 복구
3. ✅ **스토어 연동**: useReservationStore + useBookingFormStore 완전 연동

**핵심 통합 기능**:
- 🔄 **seamless 플로우**: 예약정보 입력 → 임시저장 → 로그인 → 자동복원 → 예약완료
- 📱 **사용자 친화적**: 로그인 전후 데이터 손실 없음
- 🎯 **스마트 매칭**: 서비스 ID 검증으로 올바른 서비스 페이지에서만 복원
- ⚡ **즉시 복원**: 로그인 완료 시 즉시 예약 상태 복구

**남은 작업**: 
- [ ] 사용자 알림 및 피드백 시스템 (토스트, 로딩 상태, 에러 처리)

---

**🚀 Phase 2-2 시작: 사용자 알림 및 피드백 시스템**

**작업 목표**: 전체 플로우에서 사용자 경험 개선을 위한 알림 시스템 구축

**현재 작업 중**: Phase 2-2 사용자 피드백 시스템
- [x] 임시 저장 중 로딩 상태 및 진행률 표시 ✅
- [x] 복원 성공/실패 토스트 메시지 개선 ✅
- [x] 에러 상황별 사용자 가이드 메시지 ✅
- [x] Linter 오류 수정 (토스트 훅 위치 수정) ✅
- [ ] 최종 통합 테스트 및 시나리오 검증

**Phase 2-2 거의 완료! 🎉**

**완료된 사용자 경험 개선**:
1. ✅ **토스트 메시지 개선**: 임시 저장/복원 시 더 직관적이고 구체적인 알림
2. ✅ **로딩 상태 개선**: 스피너 + 상황별 메시지 (임시저장 vs 예약생성)
3. ✅ **에러 처리 강화**: 암호화, 네트워크, 저장 오류별 구체적 가이드
4. ✅ **개발자 친화적**: 개발 환경에서만 복원 실패 알림 표시
5. ✅ **중복 토스트 방지**: 임시 저장 성공 알림 제거로 깔끔한 플로우

**사용자 경험 플로우**:
- 📦 **임시 저장**: "예약 정보 저장 중..." → 자동 리디렉션
- 🎉 **복원 완료**: "홍길동님의 예약 정보가 복원되었습니다" + 폼 자동 열기
- ⚡ **로딩**: 스피너 + 상황별 메시지
- ❌ **에러**: 구체적인 문제점 + 해결 가이드

**다음 작업**: 최종 통합 테스트 및 전체 시나리오 검증

---

**🚨 긴급 버그 수정: 이미지 무한로딩 문제 해결**

**문제 발견**: `StudioImageGallery.tsx`에서 이미지 404 오류 시 무한루프 발생
- **원인**: `onError` 핸들러에서 같은 404 이미지로 재설정하여 무한 재시도
- **증상**: `GET /images/studios/{id}/default?w=600 404` 무한 반복

**해결 방법**:
1. ✅ **실패 상태 관리**: `failedImages` Set으로 실패한 이미지 URL 추적
2. ✅ **플레이스홀더 이미지**: Unsplash 기반 안정적인 대체 이미지 사용
3. ✅ **재시도 방지**: 이미 플레이스홀더인 경우 추가 처리 방지
4. ✅ **전체 갤러리 적용**: 메인 이미지, 썸네일, 모달 이미지 모두 적용

**기술적 개선**:
- 🔄 **상태 기반 이미지 관리**: `useMemo`에서 실패 상태 반영
- 🖼️ **반응형 플레이스홀더**: 크기별 최적화된 이미지 제공
- 🛡️ **안전한 에러 처리**: 무한루프 방지 로직 추가

**결과**: 이미지 로딩 실패 시에도 안정적인 사용자 경험 제공